import heapq
import math
from typing import List, Tuple, Dict, Optional, Set

class Node3D:
    __slots__ = ('x', 'y', 'z')
    
    def __init__(self, x: float, y: float, z: float):
        self.x = x
        self.y = y
        self.z = z
        
    def __eq__(self, other):
        return (self.x == other.x and 
                self.y == other.y and 
                self.z == other.z)
    
    def __hash__(self):
        return hash((int(self.x), int(self.y), int(self.z)))
    
    def __lt__(self, other):
        return False
    
    def __repr__(self):
        return f"({self.x:.0f},{self.y:.0f},{self.z:.0f})"

class OptimizedAStar3D:
    def __init__(self):
        self.obstacles = set()
        self._distance_cache = {}
        self._neighbor_offsets = [
            (dx, dy, dz) for dx in (-1, 0, 1) 
            for dy in (-1, 0, 1) 
            for dz in (-1, 0, 1) 
            if not (dx == 0 and dy == 0 and dz == 0)
        ]
    
    def add_obstacle(self, x: float, y: float, z: float):
        self.obstacles.add(Node3D(x, y, z))
    
    def distance(self, a: Node3D, b: Node3D) -> float:
        key = (int(a.x), int(a.y), int(a.z), int(b.x), int(b.y), int(b.z))
        if key not in self._distance_cache:
            dx = a.x - b.x
            dy = a.y - b.y
            dz = a.z - b.z
            self._distance_cache[key] = math.sqrt(dx*dx + dy*dy + dz*dz)
        return self._distance_cache[key]
    
    def get_neighbors(self, node: Node3D) -> List[Node3D]:
        neighbors = []
        for dx, dy, dz in self._neighbor_offsets:
            neighbor = Node3D(node.x + dx, node.y + dy, node.z + dz)
            if neighbor not in self.obstacles:
                neighbors.append(neighbor)
        return neighbors
    
    def find_path(self, start: Tuple[float, float, float], 
                  goal: Tuple[float, float, float]) -> Optional[List[Node3D]]:
        start_node = Node3D(*start)
        goal_node = Node3D(*goal)
        
        if start_node in self.obstacles or goal_node in self.obstacles:
            return None
        
        open_set = []
        heapq.heappush(open_set, (0, start_node))
        
        g_score = {start_node: 0}
        f_score = {start_node: self.distance(start_node, goal_node)}
        came_from = {}
        open_set_hash = {start_node}
        
        # Early termination - stop when within 2 units of goal
        close_enough_threshold = 2.0
        
        while open_set:
            current_f, current = heapq.heappop(open_set)
            open_set_hash.remove(current)
            
            # Early termination for speed
            if self.distance(current, goal_node) <= close_enough_threshold:
                path = self.reconstruct_path(came_from, current)
                path.append(goal_node)
                return path
            
            if current == goal_node:
                return self.reconstruct_path(came_from, current)
            
            neighbors = self.get_neighbors(current)
            
            for neighbor in neighbors:
                tentative_g_score = g_score[current] + self.distance(current, neighbor)
                
                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g_score
                    f_score[neighbor] = tentative_g_score + self.distance(neighbor, goal_node)
                    
                    if neighbor not in open_set_hash:
                        heapq.heappush(open_set, (f_score[neighbor], neighbor))
                        open_set_hash.add(neighbor)
        
        return None
    
    def reconstruct_path(self, came_from: Dict[Node3D, Node3D], current: Node3D) -> List[Node3D]:
        path = [current]
        while current in came_from:
            current = came_from[current]
            path.append(current)
        path.reverse()
        return path
